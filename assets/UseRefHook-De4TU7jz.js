import{o as e,t}from"./index-BagyG680.js";var n=e(),r=t();function i(){let[e,t]=(0,n.useState)(0),i=(0,n.useRef)(0),[,a]=(0,n.useState)(0);return console.log(`use ref hooks function component called`,e),(0,n.useEffect)(()=>{console.log(`use ref useEffect called`,e),i.current=e},[e]),console.log(`before return`),(0,r.jsxs)(`div`,{children:[(0,r.jsx)(`h2`,{className:`mb-4`,children:`useRef Hook Page`}),(0,r.jsxs)(`div`,{className:`mb-6 p-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-r-lg`,children:[(0,r.jsx)(`h3`,{className:`font-semibold text-yellow-800 mb-2`,children:`Why previousCount.current appears "one value behind":`}),(0,r.jsxs)(`div`,{className:`text-sm text-gray-700 space-y-2`,children:[(0,r.jsxs)(`div`,{children:[(0,r.jsx)(`strong`,{children:`React's Render Cycle Behavior:`}),(0,r.jsxs)(`ol`,{className:`list-decimal list-inside mt-1 ml-4 space-y-1`,children:[(0,r.jsx)(`li`,{children:`When you click "Increment Count":`}),(0,r.jsxs)(`ul`,{className:`list-disc list-inside ml-8 space-y-1`,children:[(0,r.jsx)(`li`,{children:`setCount updates the state`}),(0,r.jsx)(`li`,{children:`Component re-renders immediately with the new count value`}),(0,r.jsx)(`li`,{children:`During this render, previousCount.current still holds the old value`}),(0,r.jsx)(`li`,{children:`Only after the render completes does useEffect run and update previousCount.current`})]})]})]}),(0,r.jsxs)(`div`,{children:[(0,r.jsx)(`strong`,{children:`Example Timeline:`}),(0,r.jsxs)(`ul`,{className:`list-disc list-inside mt-1 ml-4 space-y-1`,children:[(0,r.jsx)(`li`,{children:`Render 1: count = 0, previousCount.current = 0 → Shows "Current: 0, Previous: 0"`}),(0,r.jsx)(`li`,{children:`Click Increment → count becomes 1`}),(0,r.jsx)(`li`,{children:`Render 2: count = 1, previousCount.current = 0 (still old) → Shows "Current: 1, Previous: 0"`}),(0,r.jsx)(`li`,{children:`After Render 2: useEffect runs → previousCount.current = 1`}),(0,r.jsx)(`li`,{children:`Next Click → count becomes 2`}),(0,r.jsx)(`li`,{children:`Render 3: count = 2, previousCount.current = 1 → Shows "Current: 2, Previous: 1"`})]})]}),(0,r.jsxs)(`div`,{className:`mt-3 p-2 bg-green-50 border border-green-200 rounded`,children:[(0,r.jsx)(`strong`,{children:`Key Insight:`}),` This is the CORRECT behavior for useRef - it tracks values across renders without causing re-renders. The "one behind" behavior is exactly what makes it useful for comparing current vs previous states.`]})]})]}),(0,r.jsxs)(`div`,{children:[(0,r.jsxs)(`p`,{children:[`Current Count: `,e]}),(0,r.jsxs)(`p`,{children:[`Previous Count: `,i?i.current:`N/A`]})]}),(0,r.jsx)(`button`,{className:`p-2 bg-blue-500 text-white rounded hover:bg-blue-700`,onClick:()=>t(e=>e+1),children:`Increment Count`}),(0,r.jsx)(`button`,{className:`ml-2 p-2 bg-green-500 text-white rounded hover:bg-green-700`,onClick:()=>t(0),children:`Reset Count`}),(0,r.jsx)(`button`,{className:`ml-2 p-2 bg-gray-500 text-white rounded hover:bg-gray-700`,onClick:()=>console.log(`Current Count:`,e,`Previous Count:`,i.current),children:`Console use Ref`}),(0,r.jsx)(`button`,{className:`ml-2 p-2 bg-purple-500 text-white rounded hover:bg-purple-700`,onClick:()=>a(e=>e+1),children:`Force Re-render`})]})}var a=i;export{a as default};